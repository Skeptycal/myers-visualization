<html>
<body>


<script src="snap.svg-min.js"></script>
<script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js" 
        type="text/javascript"></script>
<script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"
        type="text/javascript"></script>

<svg width="410" height="410" id="myers">
</svg>

<script type="module">


var my_myers = function(down_string, top_string, ident) {
    var self = this
    
    rows = down_string.length + 1
    cols = top_string.length + 1

    var svg_width = 410
    var svg_height = 410

    var svg = Snap(ident)
    self.svg = svg
    self.rows = rows
    self.cols = cols
    self.top_string = top_string
    self.down_string = down_string
    self.dot_radius = 4
    self.width = svg_width
    self.height = svg_height
    self.label_xoffset = 15
    self.label_yoffset = 15 
    self.grid_offset = 5
    self.grid_width = self.width - 2 * self.grid_offset
    self.grid_height = self.height - 2 * self.grid_offset
    self.dot_xspacing = self.grid_width / self.cols
    self.dot_yspacing = self.grid_height / self.rows
    self.dot_xoffset = self.grid_offset + self.dot_xspacing / 2
    self.dot_yoffset = self.grid_offset + self.dot_yspacing / 2
 
    self.dot_x = function(row, col) {
        return self.dot_xoffset + col * self.dot_xspacing
    }

    self.dot_y = function(row, col) {
        return self.dot_yoffset + row * self.dot_yspacing
    }

    self.make_dot = function(row, col) {
        var circle = svg.circle(self.dot_x(row, col), self.dot_y(row, col), self.dot_radius)
        circle.attr({
            fill: "white",
            stroke: "black",
            strokeWidth: 1,
            })
        return circle
    }

    self.normal_line_style = {stroke: "black", strokeWidth: 1.5}
    self.current_line_style = {stroke: "red", strokeWidth: 2}

    self.connect_dots = function(row1, col1, row2, col2, solid, animate) {
        var x1 = self.dot_x(row1, col1), y1 = self.dot_y(row1, col1)
        var x2 = self.dot_x(row2, col2), y2 = self.dot_y(row2, col2)
        var line = svg.line(x1, y1, animate ? x1 : x2, animate ? y1 : y2)
        line.attr(self.normal_line_style)
        if (! solid) {
            line.attr({strokeDasharray:"1,2"})
        }
        if (animate) {
            line.animate({x2: x2, y2: y2}, 250)
        }
        return line
    }

    self.highlight_line = function(row1, col1, row2, col2, strong) {
        var x1 = self.dot_x(row1, col1), y1 = self.dot_y(row1, col1)
        var x2 = self.dot_x(row2, col2), y2 = self.dot_y(row2, col2)
        var line = svg.line(x1, y1, x2, y2)
        if (strong) {
            line.attr({stroke: "cyan", strokeWidth: 2.0, opacity: .8})
        } else {
            line.attr({stroke: "blue", strokeWidth: 2.0, opacity: .15})
        }
        return line
    }

    self.highlight_point = function(row, col) {
        var x = self.dot_x(row, col)
        var xy = self.dot_y(row, col)
        var circle = svg.circle(self.dot_x(row, col), self.dot_y(row, col), self.dot_radius)
        circle.attr({
            fill: "white",
            stroke: "cyan",
            strokeWidth: 2,
            })
        return circle
    }

    self.make_label = function(is_vertical, row, col, txt) {
        var x = is_vertical ? self.label_xoffset : self.dot_xoffset + self.dot_xspacing / 2
        var y = is_vertical ? self.dot_yoffset + self.dot_yspacing / 2 : self.label_yoffset
        x += col * self.dot_xspacing
        y += row * self.dot_yspacing
        text_obj = self.svg.text(x, y, txt)
        text_obj.attr({textAnchor: is_vertical ? "middle" : "end"})
        return text_obj
    }

    // Reports if a line [x0, y0, x1, y1] is at all contained within our grid
    self.line_intersects_grid = function(line) {
        var result = false
        if (line.length == 4) {
            var xBad = (line[0] < 0 && line[2] < 0) || (line[0] >= self.cols)
            var yBad = (line[1] < 0 && line[3] < 0) || (line[1] >= self.rows)
            result = ! xBad && ! yBad
        }
        return result
    }


    // Make the labels
    for (var x=0; x < top_string.length; x++) {
        make_label(false, 0, x, top_string[x])
    }
    for (var y=0; y < down_string.length; y++) {
        make_label(true, y, 0, down_string[y])
    }

    // Make the grid
    self.grid = new Array(rows)
    for (var row=0; row < rows; row++) {
        self.grid[row] = new Array(cols)
        for (var col = 0; col < cols; col++) {
            self.grid[row][col] = self.make_dot(row, col)
       }
    }

    // Add paths
    for (var y=0; y < self.rows; y++) {
        for (var x=0; x < self.cols; x++) {
            if (y + 1 < self.rows) {
                // down path
                connect_dots(y, x, y+1, x, false, false)
            }
            if (x + 1 < self.cols) {
                // right path
                connect_dots(y, x, y, x+1, false, false)
            }

            if (y < down_string.length && x < top_string.length && down_string[y] == top_string[x]) {
                connect_dots(y, x, y + 1, x+1, false, false)
            }
        }
    }

    return self
}


function visualization_result(line, diagonal, candidate_lines, reset_highlight, myers) {
    var self = this
    self.line = line
    self.candidate_lines = candidate_lines
    self.reset_highlight = reset_highlight

    if (isNaN(diagonal)) {
        self.diagonal = []
    } else {
        // Diagonals are of the form x - y
        // Compute start and end points for it
        var startX = 0, startY = 0
        if (diagonal < 0) {
            startY = -diagonal
        } else {
            startX = diagonal
        }
    
        // Hacktastic
        var endX = startX, endY = startY
        while (endX + 1 < myers.cols && endY + 1 < myers.rows) {
            endX++;
            endY++;
        }
        self.diagonal = [startX, startY, endX, endY]
    }
    return self
}

// Single directional myers diff algorithm
function* step_myers_unidir_coroutine(myers) {
    var endpoints = new Array()
    endpoints[1] = 0

    var top_len = myers.top_string.length
    var down_len = myers.down_string.length
    var MAX = Math.max(top_len, down_len)
    var done = false
    for (var step=0; step <= MAX && ! done; step++) {
        for (var diagonal = -step; diagonal <= step; diagonal+=2) {

            // Helper function
            function get_y(x) {
                return x - diagonal
            }

            function get_line(x, down) {
                // if down is true, we are starting from the diagonal above us, which is larger
                // if down is false, we are starting from the diagonal to our left, which is smaller
                var other_diagonal = diagonal + (down ? 1 : -1)
                var start_x = x - (down ? 0 : 1)
                var start_y = start_x - other_diagonal
                return [start_x, start_y, start_x + (down ? 0 : 1), start_y + (down ? 1 : 0)]
            }

            var go_down
            var candidate_lines = []
            if (diagonal == -step) {
                var top_x = endpoints[diagonal+1]
                go_down = true
                candidate_lines.push(get_line(top_x, go_down))
            } else if (diagonal == step) {
                var left_x = endpoints[diagonal-1]
                go_down = false
                candidate_lines.push(get_line(left_x + 1, go_down))
            } else {
                var left_x = endpoints[diagonal-1], top_x = endpoints[diagonal+1]
                go_down = left_x < top_x
                candidate_lines.push(get_line(top_x, true), get_line(left_x + 1, false))
            }

            var x
            if (go_down) {
                // go down
                x = endpoints[diagonal + 1]
            } else {
                // go right
                x = endpoints[diagonal - 1] + 1
            }
            var y = x - diagonal

            yield new visualization_result([x - (go_down ? 0 : 1), y - (go_down ? 1 : 0), x, y], diagonal, candidate_lines, true, myers)

            while (x < top_len && y < down_len && myers.top_string[x] == myers.down_string[y]) {
                x++
                y++
                yield new visualization_result([x-1, y-1, x, y], NaN, [], false, myers)
            }

            endpoints[diagonal] = x
            if (x >= top_len && y >= down_len) {
                done = true
                break
            }
        }
    }
}

var myers = my_myers("INCANTANTION", "AARDVARDK", "#myers")

function remove_elements(elems) {
    var i = elems.length;
    while (i--) {
        elems.pop().remove()
    }
}

var begin_stepping = function() {
    var gener = step_myers_unidir_coroutine(myers)
    var highlight_lines = []
    var normal_lines = []
    var styled_normal_lines = []

    function execute_step() {
        for (;;) {
            var ret = gener.next()
            if (ret.done) {
                break
            } else {
                var vis_result = ret.value
                var diagonal = vis_result.diagonal
                var line = vis_result.line
                var candidate_lines = vis_result.candidate_lines
                var reset_highlight = vis_result.reset_highlight

                // Keep going if there's nothing to show
                if (! myers.line_intersects_grid(diagonal) && ! myers.line_intersects_grid(line)) {
                    continue
                }


                // Clear highlight lines and styled normal lines
                if (reset_highlight) {
                    remove_elements(highlight_lines)
                    while (styled_normal_lines.length) {
                        styled_normal_lines.pop().attr(myers.normal_line_style)
                    }
                }

                // Add candidate lines
                for (var i=0; i < candidate_lines.length; i++) {
                    var candidate_line = candidate_lines[i]
                    highlight_lines.push(myers.highlight_line(candidate_line[1], candidate_line[0], candidate_line[3], candidate_line[2], true))
                }

                if (myers.line_intersects_grid(diagonal)) {
                    var highlight_line = myers.highlight_line(diagonal[1], diagonal[0], diagonal[3], diagonal[2], false)
                    highlight_lines.push(highlight_line)
                }

                // Schedule an animation
                setTimeout(function() {
                    if (myers.line_intersects_grid(line)) {
                        new_line = myers.connect_dots(line[1], line[0], line[3], line[2], true, true)
                        normal_lines.push(new_line)

                        // Style it
                        new_line.attr(myers.current_line_style)
                        styled_normal_lines.push(new_line)
                    }

                    // Schedule the next step
                    setTimeout(execute_step, 1500)
                }, 1500)

                break
            }
        }
    }

    execute_step()
}

begin_stepping()

</script>

</body>
</html>


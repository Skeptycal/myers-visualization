<html>
<body>


<script src="snap.svg-min.js"></script>
<script src="https://traceur-compiler.googlecode.com/git/bin/traceur.js" 
        type="text/javascript"></script>
<script src="https://traceur-compiler.googlecode.com/git/src/bootstrap.js"
        type="text/javascript"></script>

<svg width="410" height="410" id="myers">
</svg>

<script type="module">

var my_myers = function(down_string, top_string, ident) {
    var self = this
    
    rows = down_string.length + 1
    cols = top_string.length + 1

    var svg_width = 410
    var svg_height = 410

    var svg = Snap(ident)
    self.svg = svg
    self.rows = rows
    self.cols = cols
    self.top_string = top_string
    self.down_string = down_string
    self.dot_radius = 4
    self.width = svg_width
    self.height = svg_height
    self.label_xoffset = 15
    self.label_yoffset = 15 
    self.grid_offset = 5
    self.grid_width = self.width - 2 * self.grid_offset
    self.grid_height = self.height - 2 * self.grid_offset
    self.dot_xspacing = self.grid_width / self.cols
    self.dot_yspacing = self.grid_height / self.rows
    self.dot_xoffset = self.grid_offset + self.dot_xspacing / 2
    self.dot_yoffset = self.grid_offset + self.dot_yspacing / 2
 
    self.dot_x = function(row, col) {
        return self.dot_xoffset + col * self.dot_xspacing
    }

    self.dot_y = function(row, col) {
        return self.dot_yoffset + row * self.dot_yspacing
    }

    self.make_dot = function(row, col) {
        var circle = svg.circle(self.dot_x(row, col), self.dot_y(row, col), self.dot_radius)
        circle.attr({
            fill: "white",
            stroke: "black",
            strokeWidth: 1,
            })
        return circle
    }

    self.connect_dots = function(row1, col1, row2, col2, solid, animate) {
        var x1 = self.dot_x(row1, col1), y1 = self.dot_y(row1, col1)
        var x2 = self.dot_x(row2, col2), y2 = self.dot_y(row2, col2)
        var line = svg.line(x1, y1, animate ? x1 : x2, animate ? y1 : y2)
        line.attr({stroke: "black", strokeWidth: 1.05})
        if (! solid) {
            line.attr({strokeDasharray:"1,2"})
        }
        if (animate) {
            line.animate({x2: x2, y2: y2}, 250)
        }
        return line
    }

    self.make_label = function(is_vertical, row, col, txt) {
        var x = is_vertical ? self.label_xoffset : self.dot_xoffset + self.dot_xspacing / 2
        var y = is_vertical ? self.dot_yoffset + self.dot_yspacing / 2 : self.label_yoffset
        x += col * self.dot_xspacing
        y += row * self.dot_yspacing
        text_obj = self.svg.text(x, y, txt)
        text_obj.attr({textAnchor: is_vertical ? "middle" : "end"})
        return text_obj
    }

    // Make the labels
    for (var x=0; x < top_string.length; x++) {
        make_label(false, 0, x, top_string[x])
    }
    for (var y=0; y < down_string.length; y++) {
        make_label(true, y, 0, down_string[y])
    }

    // Make the grid
    self.grid = new Array(rows)
    for (var row=0; row < rows; row++) {
        self.grid[row] = new Array(cols)
        for (var col = 0; col < cols; col++) {
            self.grid[row][col] = self.make_dot(row, col)
       }
    }

    // Add paths
    for (var y=0; y < self.rows; y++) {
        for (var x=0; x < self.cols; x++) {
            if (y + 1 < self.rows) {
                // down path
                connect_dots(y, x, y+1, x, false, false)
            }
            if (x + 1 < self.cols) {
                // right path
                connect_dots(y, x, y, x+1, false, false)
            }

            if (y < down_string.length && x < top_string.length && down_string[y] == top_string[x]) {
                connect_dots(y, x, y + 1, x+1, false, false)
            }
        }
    }

    return self
}

// Single directional myers diff algorithm
function* step_myers_unidir_coroutine(myers) {
    var endpoints = new Array()
    endpoints[1] = 0

    var top_len = myers.top_string.length
    var down_len = myers.down_string.length
    var MAX = Math.max(top_len, down_len)
    var done = false
    for (var step=0; step <= MAX && ! done; step++) {
        for (var diagonal = -step; diagonal <= step; diagonal+=2) {
            var go_down
            if (diagonal == -step) {
                go_down = true
            } else if (diagonal == step) {
                go_down = false
            } else {
                go_down = endpoints[diagonal-1] < endpoints[diagonal + 1]
            }

            var x
            if (go_down) {
                // go down
                x = endpoints[diagonal + 1]
            } else {
                // go right
                x = endpoints[diagonal - 1] + 1
            }
            var y = x - diagonal

            yield [x - (go_down ? 0 : 1), y - (go_down ? 1 : 0), x, y]

            while (x < top_len && y < down_len && myers.top_string[x] == myers.down_string[y]) {
                x++
                y++
                yield [x-1, y-1, x, y]
            }

            endpoints[diagonal] = x
            if (x >= top_len && y >= down_len) {
                done = true
                break
            }
        }
    }
}

var myers = my_myers("SMOLE", "MILESSS", "#myers")

var begin_stepping = function() {
    var gener = step_myers_unidir_coroutine(myers)
    var timer = setInterval(function() {
        for (;;) {
            var ret = gener.next()
            if (ret.done) {
                clearInterval(timer)
                break
            } else {
                var line = ret.value
                console.log(line)
                if (line[0] >= 0 && line[0] < myers.cols &&
                    line[1] >= 0 && line[1] < myers.rows &&
                    line[2] >= 0 && line[2] < myers.cols &&
                    line[3] >= 0 && line[3] < myers.rows) {
                    myers.connect_dots(line[1], line[0], line[3], line[2], true, true)
                    break
                }
            }
        }
    }, 500)
}

begin_stepping()

</script>

</body>
</html>

